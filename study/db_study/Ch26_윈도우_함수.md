# 공부한 내용

## **1. WINDOW FUNCTION 개요**

기존 관계형 데이터베이스에서는 칼럼과 칼럼간의 연산은 쉽게할 수 있었지만, 행과 행간의 비교 및 연산은 어려웠다.

WINDOW FUNCTION은 이러한 문제를 해결하기 위해 생긴 개념으로, 분석 함수 / 순위 함수로도 알려져 있다.

### WINDOW FUNCTION의 종류

- 그룹 내 순위(RANK) 관련 함수는 다음과 같다.
  - RANK
  - DENSE_RANK
  - ROW_NUMBER

- 그룹 내 집계(AGGREGATE) 관련 함수는 다음과 같다.
  - SUM
  - MAX
  - MIN
  - AVG
  - COUNT

- 그룹 내 행 순서 관련 함수는 다음과 같다.
  - FIRST_VALUE → MAX와 비슷
  - LAST_VALUE → MIN과 비슷
  - LAG
  - LEAD

- 그룹 내 비율 관련 함수는 다음과 같다.
  - CUME_DIST
  - PERCENT_RANK
  - NTILE
  - RATIO_TO_REPORT

- 통계 분석 관련 함수도 있으나 딱히 쓸 일이 없을 듯 하다.

### WINDOW FUNCTION 사용 방법

WINDOW 함수에는 OVER 문구가 키워드로 필수 포함된다.

```sql
SELECT WINDOW_FUNCTION (ARGUMENTS) 
OVER ( 
	[PARTITION BY 칼럼] 
	[ORDER BY 절] 
	[WINDOWING 절] 
) 
FROM 테이블 명;
```

## **2. 그룹 내 순위 함수**

### RANK 함수

ORDER BY를 포함한 QUERY 문에서 특정 항목(칼럼)에 대한 순위를 구하는 함수이다.

```sql
 SELECT JOB, ENAME, SAL, 
 RANK( ) OVER (
	 ORDER BY SAL DESC
 ) ALL_RANK, 
 RANK( ) OVER (
	 PARTITION BY JOB ORDER BY SAL DESC
 ) JOB_RANK 
 FROM EMP;
```

### DENSE_RANK 함수

RANK 함수와 비슷하나, 동일한 순위를 하나의 건수로 취급한다.

```sql
SELECT JOB, ENAME, SAL, 
RANK( ) OVER (ORDER BY SAL DESC) RANK, 
DENSE_RANK( ) OVER (ORDER BY SAL DESC) DENSE_RANK 
FROM EMP;
```

### **ROW_NUMBER 함수**

RANK, DENSE_RANK와 달리 동일한 값에 대해 동일한 순위가 아닌, 고유한 순위를 부여한다.

ex. 공동 2등이란 개념이 없고 무조건 2등, 3등으로 나뉘는 느낌이다.

```sql
SELECT JOB, ENAME, SAL, 
RANK( ) OVER (ORDER BY SAL DESC) RANK, 
ROW_NUMBER() OVER (ORDER BY SAL DESC) ROW_NUMBER 
FROM EMP;
```
## 3. **일반 집계 함수**

### SUM

파티션별 윈도우의 합을 구한다.

```sql
SELECT MGR, ENAME, SAL, SUM(SAL) 
OVER (PARTITION BY MGR) MGR_SUM 
FROM EMP; 
```

### MAX

파티션별 윈도우의 최대값을 구한다.

```sql
SELECT MGR, ENAME, SAL, 
MAX(SAL) OVER (PARTITION BY MGR) as MGR_MAX 
FROM EMP;
```

### MIN

파티션별 윈도우의 최소값을 구할 수 있다.

```sql
SELECT MGR, ENAME, HIREDATE, SAL, 
MIN(SAL) OVER(
	PARTITION BY MGR ORDER BY HIREDATE
) as MGR_MIN 
FROM EMP;
```

### AVG

ROWS 윈도우와 함께 쓰면 원하는 조건에 맞는 데이터에 대한 통계값을 구할 수 있다.

```sql
SELECT MGR, ENAME, HIREDATE, SAL, 
ROUND (
	AVG(SAL) OVER (
		PARTITION BY MGR 
		ORDER BY HIREDATE 
		ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
		)
) as MGR_AVG 
FROM EMP;
```

### COUNT

ROWS 윈도우와 함께 쓰면 원하는 조건에 맞는 데이터에 대한 통계값을 구할 수 있다.

```sql
SELECT ENAME, SAL, 
COUNT(*) OVER (
	ORDER BY SAL RANGE 
	BETWEEN 50 PRECEDING AND 150 FOLLOWING
) as SIM_CNT 
FROM EMP;
```




# 궁금한 내용 / 부족한 내용

# 느낀점