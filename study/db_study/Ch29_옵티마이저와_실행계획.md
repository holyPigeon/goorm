# 공부한 내용

## 1. 옵티마이저

옵티마이저(Optimizer)는 사용자가 질의한 SQL문에 대해 최적의 실행 방법(=실행 계획)을 결정하는 역할을 수행한다.

C나 Java처럼 SQL도 사용자의 요구사항에 대해 다양한 방법으로 처리할 수 있는데, 다만 그것을 사용자가 직접 선택하지는 않고 옵티마이저가 알아서 처리하는 느낌이다.

이 때 실행계획을 결정하는 방식에 대해서는 규칙기반 옵티마이저와 비용기반 옵티마이저로 나뉜다.

(대부분의 DB는 비용기반 옵티마이저롤 사용한다.)

사용자가 SQL을 입력하고, 이것의 실행결과가 다시 반환되기까지는 다음과 같은 과정이 있다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_239.jpg)

### 규칙기반 옵티마이저

규칙기반 옵티마이저는 다음과 같은 우선순위에 따라 작업을 수행한다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_240.jpg)

많은 규칙들이 있지만, 기본적으로는 인덱스를 이용한 엑세스 방식을 전체 테이블에 엑세스 방식보다 우선시하는 모습을 보인다.

### 비용기반 옵티마이저

규칙기반 옵티마이저는 대부분의 경우에서 그 판단이 맞지만, 수백 수천 개의 규칙이 존재하는 것은 아니기 때문에 예외 또한 존재한다.

이러한 상황 속에서 비용기반 옵티마이저가 출현하였다. 비용기반 옵티마이저는 말 그대로 최소 비용을 가진 실행계획을 선택한다.

비용기반 옵티마이저는 다음과 같은 방식으로 작동한다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_241.jpg)

- 질의 변환기 → 사용자가 작성한 SQL문을 보다 처리하기 용이하게 변환한다.
- 대안 계획 생성기 → 동일한 결과를 반환할 수 있는 여러가지 계획을 생성한다.
    - 다음과 같은 방법들을 통해 대안을 생성한다.
    - 연산의 적용순서 변경
    - 연산 방법 변경
    - 조인 순서 변경
    - 하지만 너무 많은 대안을 생성하면 최적화를 수행하는 시간 자체가 너무 길어지므로 보통은 개수를 제한한다.
- 비용 예측기 → 생성된 대안들의 비용을 에측한다.
    - 다음 요소들을 기준으로 예측한다.
    - 연산의 중간 집합의 크기
    - 결과 집합의 크기
    - 분포도
    - 정확한 통계정보가 필요하다.

규칙기반 옵티마이저는 인덱스가 있다면 항상 인덱스를 사용하는 쪽으로 가지만, 비용기반 옵티마이저는 인덱스가 있더라도 비용이 높으면 그냥 전체 테이블에 엑세스하는 쪽으로 간다.

## 2. 실행 계획

실행 계획 → 최적의 실행 계획을 뜻하며, 실행 계획은 다음과 같은 요소들로 구성된다.

### 조인 순서

조인할 때 어떤 테이블을 먼저 읽을지 정한다.

### 조인 기법

두 테이블을 조인할 때 사용할 수 있는 방법이다.

(ex. NL Join(중첩 루프 조인), Hash Join, Sort Merge Join)

### 엑세스 기법

하나의 테이블에 액세스할 때 사용할 수 있는 방법이다.

(ex. 인덱스 스캔과 전체 테이블 스캔)

### 최적화 정보

각 단계마다 예상되는 비용을 뜻한다.

### 연산

SQL에서 원하는 결과를 얻기 위해 수행하는 다양한 작업이다.

(ex. 조인, 액세스, 필터, 정렬, 집계, 뷰)

## 3. **SQL 처리 흐름도**

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_243.jpg)

음… 그렇다고 한다.

# 궁금한 내용 / 부족한 내용

---

# 느낀점

---