# 공부한 내용

## 1. 옵티마이저

옵티마이저(Optimizer)는 사용자가 질의한 SQL문에 대해 최적의 실행 방법(=실행 계획)을 결정하는 역할을 수행한다.

C나 Java처럼 SQL도 사용자의 요구사항에 대해 다양한 방법으로 처리할 수 있는데, 다만 그것을 사용자가 직접 선택하지는 않고 옵티마이저가 알아서 처리하는 느낌이다.

이 때 실행계획을 결정하는 방식에 대해서는 규칙기반 옵티마이저와 비용기반 옵티마이저로 나뉜다.

(대부분의 DB는 비용기반 옵티마이저롤 사용한다.)

사용자가 SQL을 입력하고, 이것의 실행결과가 다시 반환되기까지는 다음과 같은 과정이 있다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_239.jpg)

### 규칙기반 옵티마이저

규칙기반 옵티마이저는 다음과 같은 우선순위에 따라 작업을 수행한다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_240.jpg)

많은 규칙들이 있지만, 기본적으로는 인덱스를 이용한 엑세스 방식을 전체 테이블에 엑세스 방식보다 우선시하는 모습을 보인다.

### 비용기반 옵티마이저

규칙기반 옵티마이저는 대부분의 경우에서 그 판단이 맞지만, 수백 수천 개의 규칙이 존재하는 것은 아니기 때문에 예외 또한 존재한다.

이러한 상황 속에서 비용기반 옵티마이저가 출현하였다. 비용기반 옵티마이저는 말 그대로 최소 비용을 가진 실행계획을 선택한다.

비용기반 옵티마이저는 다음과 같은 방식으로 작동한다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_241.jpg)

- 질의 변환기 → 사용자가 작성한 SQL문을 보다 처리하기 용이하게 변환한다.
- 대안 계획 생성기 → 동일한 결과를 반환할 수 있는 여러가지 계획을 생성한다.
    - 다음과 같은 방법들을 통해 대안을 생성한다.
    - 연산의 적용순서 변경
    - 연산 방법 변경
    - 조인 순서 변경
    - 하지만 너무 많은 대안을 생성하면 최적화를 수행하는 시간 자체가 너무 길어지므로 보통은 개수를 제한한다.
- 비용 예측기 → 생성된 대안들의 비용을 에측한다.
    - 다음 요소들을 기준으로 예측한다.
    - 연산의 중간 집합의 크기
    - 결과 집합의 크기
    - 분포도
    - 정확한 통계정보가 필요하다.

규칙기반 옵티마이저는 인덱스가 있다면 항상 인덱스를 사용하는 쪽으로 가지만, 비용기반 옵티마이저는 인덱스가 있더라도 비용이 높으면 그냥 전체 테이블에 엑세스하는 쪽으로 간다.

## 2. 실행 계획

실행 계획 → 최적의 실행 계획을 뜻하며, 실행 계획은 다음과 같은 요소들로 구성된다.

### 조인 순서

조인할 때 어떤 테이블을 먼저 읽을지 정한다.

### 조인 기법

두 테이블을 조인할 때 사용할 수 있는 방법이다.

(ex. NL Join(중첩 루프 조인), Hash Join, Sort Merge Join)

### 엑세스 기법

하나의 테이블에 액세스할 때 사용할 수 있는 방법이다.

(ex. 인덱스 스캔과 전체 테이블 스캔)

### 최적화 정보

각 단계마다 예상되는 비용을 뜻한다.

### 연산

SQL에서 원하는 결과를 얻기 위해 수행하는 다양한 작업이다.

(ex. 조인, 액세스, 필터, 정렬, 집계, 뷰)

## 3. **SQL 처리 흐름도**

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_243.jpg)

음… 그렇다고 한다.

# 궁금한 내용 / 부족한 내용

비용기반 옵티마이저가 비용 계산을 하는 과정에서 통계정보가 왜 중요한지 궁금해졌다.

## Q1. 비용기반 옵티마이저가 비용을 계산할 때 쓰는 통계정보에는 어떤 것들이 있을까?

A. 먼저 여기서 말하는 통계 정보에는 다음과 같은 요소들이 있다.

- 테이블의 크기
- 칼럼의 데이터 분포
- 인덱스의 존재 유무 및 특성
- 데이터의 유니크한 값의 수(카디널리티)
- 테이블 간의 관계

## Q2. 그렇다면 이러한 요소들을 기반으로 어떻게 비용추산을 할까?

### 리소스 사용

먼저 테이블의 크기나 데이터의 분포같은 경우는 디스크 I/O, CPU를 얼마나 사용할지 고려하는 과정에서 쓰인다.

### 최적의 조인

또한, 조인 과정에서 최적의 조인 방법과 순서는 어떤 것인지 결정하는 데도 도움을 준다.

### 인덱스 사용 결정

인덱스 스캔을 결정할 것인지에 대한 부분도 이러한 요소들을 보고 판단한다.

(ex. 유니크한 칼럼값이 많고 쿼리 조건에 맞는 데이터가 테이블의 작은 부분에만 존재한다면, 인덱스 스캔이 더 낮은 비용으로 더 빠른 결과를 가져온다고 판단할 수 있다.)

# 느낀점

---