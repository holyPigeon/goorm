# 공부한 내용

## **1. 인덱스 특징과 종류**

인덱스는 원하는 데이터를 쉽게 찾을 수 있도록 해주는 책의 목차와 유사한 개념이다. 주 목적은 검색 성능의 최적화이다.

![](https://user-images.githubusercontent.com/24884819/56257764-5bd79b00-6108-11e9-9772-56d667903602.png)

위와 같이 목차를 통해 해당 데이터가 어느 위치에 있는지 확인하고, 그 즉시 찾아갈 수 있다는 특징이 있다.

인덱스는 테이블마다 선택적으로 생성할 수 있다.

→ 여러 개 생성해도 되고, 아예 생성하지 않아도 된다.

조회(SELECT) 성능은 향상되지만, 나머지 데이터 조작(INSERT, UPDATE, DELETE) 등의 작업에서는 성능이 오히려 저하되는 Trade-Off가 존재한다.

### 트리 기반 인덱스

DBMS에서 사용되는 가장 일반적인 인덱스는 B-트리 인덱스다.

B-Tree는 Balanced-Tree라는 뜻인데, 이는  이진탐색 시 양쪽 균형이 맞는 트리의 형태가 되므로 균형이 안 맞는 트리보다 탐색이 더 빨라지는 형태이다.

다음은 B-트리 인덱스 구조이다. 인덱스 데이터는 정렬되어 있고, 리프 블록들이 서로 양방향 링크로 연결되어 있음을 알 수 있다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/1bbacdcd-24fd-456c-a484-004dc9682782/Untitled.png)

다음은 B-Tree 인덱스가 탐색을 진행하는 과정을 담은 사진이다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/66c5fcf2-26f0-4725-ad57-da8f1dfca4ef/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.36.07.png)

인덱스에서는 동일한 칼럼 구성이라도, 칼럼의 순서가 다르면 서로 다른 인덱스로 생성할 수 있는데, 이 칼럼 순서는 질의 성능에 중요한 영향을 미치는 요소이다.

Oracle에서 트리 기반 인덱스에는 B-트리 인덱스 외에도 비트맵 인덱스(Bitmap Index), 리버스 키 인덱스(Reverse Key Index), 함수기반 인덱스(FBI, Function-Based Index) 등이 존재한다.

### **클러스터링 인덱스와 논-클러스터링 인덱스**

둘을 쉽게 말하자면 클러스터링 인덱스는 실제 데이터와 같이 있는 인덱스, 논-클러스터링 인덱스는 실제 데이터와 같이 있지 않은 인덱스라고 할 수 있다.

다음과 같이 클러스터링 인덱스는 리프 페이지에서 실제 데이터를 가지게 된다. 별다른 절차 없이 리프 페이지에서 즉시 데이터를 찾아내는 것을 확인할 수 있다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/d7fa5913-661c-4e21-8c28-6be97f9f7fe3/Untitled.png)

다음과 같이 논-클러스터링 인덱스의 경우, 페이지 주소를 통해 리프 페이지에서 데이터 페이지로 이동, 탐색하여 데이터를 찾게 된다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/63ed6272-f6e3-4140-8144-80172185cf2e/Untitled.png)

전체적으로 정리하자면 다음과 같다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/f681ae36-4478-4ec4-a484-d6b440ac6f0b/Untitled.png)

## 2. 전체 테이블 스캔과 인덱스 스캔

### 전체 테이블 스캔

말 그대로 전체 테이블을 모두 읽어보는 것을 뜻한다. 전체 테이블 스캔은 어떤 경우에 하는 것일까?

### 1. SQL문에 조건이 존재하지 않는 경우

SQL문에 조건이 존재하지 않는다는 것은 그냥 테이블에 있는 모든 데이터를 그대로 반환하면 된다는 뜻이므로 전체 테이블 스캔을 진행한다.

### 2. SQL문의 주어진 조건에 사용 가능한 인덱스가 존재하는 않는 경우

사용 가능한 인덱스가 만들어져 있지 않다면 당연하게도 인덱스를 사용할 수 없다.

또한 사용 가능한 인덱스가 존재하더라도, 함수를 사용하여 인덱스 칼럼을 변형한 경우에도 인덱스를 사용할 수 없다.

예를 들어 birth라는 칼럼이 있는데, 쿼리에 YEAR(birth)와 같이 함수처리를 해서 넣어버리면 인덱스 측에서는 birth와 YEAR(birth)를 엄연히 다른 것으로 인식하기 때문에 인덱스 사용이 불가하다.

### 3. 옵티마이저의 취사 선택

옵티마이저의 선택에 따라 인덱스가 있지만 사용하지 않을 수도 있다. 아마도 비용적으로 인덱스를 사용하는 게 오히려 더 비싸다면, 전체 테이블 접근을 선택할 수 있다.

(ex. 크기가 작은 테이블을 탐색할 때, 테이블 상의 거의 대부분의 데이터를 탐색할 때)

인덱스 스캔을 사용할 경우 한 번의 I/O 요청으로 한 블록씩 데이터를 읽어오지만, 전체 테이블 스캔은 한 번의 I/O 요청으로 여러 블록을 한꺼번에 읽어오므로, 테이블 상의 거의 모든 데이터를 읽어야 한다면 후자가 훨씬 효율적이다.

### 4. 그 밖의 경우

병렬처리 방식으로 처리하는 경우 또는 전체 테이블 스캔 방식의 힌트를 사용한 경우에 전체 테이블 스캔 방식으로 데이터를 읽을 수 있다.