# 공부한 내용

## **1. 인덱스 특징과 종류**

인덱스는 원하는 데이터를 쉽게 찾을 수 있도록 해주는 책의 목차와 유사한 개념이다. 주 목적은 검색 성능의 최적화이다.

![](https://user-images.githubusercontent.com/24884819/56257764-5bd79b00-6108-11e9-9772-56d667903602.png)

위와 같이 목차를 통해 해당 데이터가 어느 위치에 있는지 확인하고, 그 즉시 찾아갈 수 있다는 특징이 있다.

인덱스는 테이블마다 선택적으로 생성할 수 있다.

→ 여러 개 생성해도 되고, 아예 생성하지 않아도 된다.

조회(SELECT) 성능은 향상되지만, 나머지 데이터 조작(INSERT, UPDATE, DELETE) 등의 작업에서는 성능이 오히려 저하되는 Trade-Off가 존재한다.

### 트리 기반 인덱스

DBMS에서 사용되는 가장 일반적인 인덱스는 B-트리 인덱스다.

B-Tree는 Balanced-Tree라는 뜻인데, 이는  이진탐색 시 양쪽 균형이 맞는 트리의 형태가 되므로 균형이 안 맞는 트리보다 탐색이 더 빨라지는 형태이다.

다음은 B-트리 인덱스 구조이다. 인덱스 데이터는 정렬되어 있고, 리프 블록들이 서로 양방향 링크로 연결되어 있음을 알 수 있다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/1bbacdcd-24fd-456c-a484-004dc9682782/Untitled.png)

다음은 B-Tree 인덱스가 탐색을 진행하는 과정을 담은 사진이다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/66c5fcf2-26f0-4725-ad57-da8f1dfca4ef/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.36.07.png)

인덱스에서는 동일한 칼럼 구성이라도, 칼럼의 순서가 다르면 서로 다른 인덱스로 생성할 수 있는데, 이 칼럼 순서는 질의 성능에 중요한 영향을 미치는 요소이다.

Oracle에서 트리 기반 인덱스에는 B-트리 인덱스 외에도 비트맵 인덱스(Bitmap Index), 리버스 키 인덱스(Reverse Key Index), 함수기반 인덱스(FBI, Function-Based Index) 등이 존재한다.

### **클러스터링 인덱스와 논-클러스터링 인덱스**

둘을 쉽게 말하자면 클러스터링 인덱스는 실제 데이터와 같이 있는 인덱스, 논-클러스터링 인덱스는 실제 데이터와 같이 있지 않은 인덱스라고 할 수 있다.

다음과 같이 클러스터링 인덱스는 리프 페이지에서 실제 데이터를 가지게 된다. 별다른 절차 없이 리프 페이지에서 즉시 데이터를 찾아내는 것을 확인할 수 있다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/d7fa5913-661c-4e21-8c28-6be97f9f7fe3/Untitled.png)

다음과 같이 논-클러스터링 인덱스의 경우, 페이지 주소를 통해 리프 페이지에서 데이터 페이지로 이동, 탐색하여 데이터를 찾게 된다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/63ed6272-f6e3-4140-8144-80172185cf2e/Untitled.png)

전체적으로 정리하자면 다음과 같다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/f681ae36-4478-4ec4-a484-d6b440ac6f0b/Untitled.png)

## 2. 전체 테이블 스캔과 인덱스 스캔

### 전체 테이블 스캔

말 그대로 전체 테이블을 모두 읽어보는 것을 뜻한다. 전체 테이블 스캔은 어떤 경우에 하는 것일까?

### 1. SQL문에 조건이 존재하지 않는 경우

SQL문에 조건이 존재하지 않는다는 것은 그냥 테이블에 있는 모든 데이터를 그대로 반환하면 된다는 뜻이므로 전체 테이블 스캔을 진행한다.

### 2. SQL문의 주어진 조건에 사용 가능한 인덱스가 존재하는 않는 경우

사용 가능한 인덱스가 만들어져 있지 않다면 당연하게도 인덱스를 사용할 수 없다.

또한 사용 가능한 인덱스가 존재하더라도, 함수를 사용하여 인덱스 칼럼을 변형한 경우에도 인덱스를 사용할 수 없다.

예를 들어 birth라는 칼럼이 있는데, 쿼리에 YEAR(birth)와 같이 함수처리를 해서 넣어버리면 인덱스 측에서는 birth와 YEAR(birth)를 엄연히 다른 것으로 인식하기 때문에 인덱스 사용이 불가하다.

### 3. 옵티마이저의 취사 선택

옵티마이저의 선택에 따라 인덱스가 있지만 사용하지 않을 수도 있다. 아마도 비용적으로 인덱스를 사용하는 게 오히려 더 비싸다면, 전체 테이블 접근을 선택할 수 있다.

(ex. 크기가 작은 테이블을 탐색할 때, 테이블 상의 거의 대부분의 데이터를 탐색할 때)

인덱스 스캔을 사용할 경우 한 번의 I/O 요청으로 한 블록씩 데이터를 읽어오지만, 전체 테이블 스캔은 한 번의 I/O 요청으로 여러 블록을 한꺼번에 읽어오므로, 테이블 상의 거의 모든 데이터를 읽어야 한다면 후자가 훨씬 효율적이다.

### 4. 그 밖의 경우

병렬처리 방식으로 처리하는 경우 또는 전체 테이블 스캔 방식의 힌트를 사용한 경우에 전체 테이블 스캔 방식으로 데이터를 읽을 수 있다.

### 인덱스 스캔

인덱스 스캔의 경우, 인덱스 상에 요구하는 데이터가 모두 없다면 테이블에 접근해 추가적으로 데이터를 스캔하지만, 요구 데이터가 모두 있다면 인덱스만을 스캔하게 된다.

또한 인덱스는 인덱스 구성 칼럼의 순서로 정렬되어 있어서, 순서가 A + B일 경우 A 먼저 정렬되고 그 뒤에 A를 기준으로 B가 정렬된다.

- 인덱스 스캔 방법의 종류는 다음과 같다.
    - 인덱스 유일 스캔
    - 인덱스 범위 스캔 / 역순 범위 스캔

인덱스 유일 스캔의 경우, 유일 인덱스(Unique Index)를 이용해 단 하나의 데이터를 추출한다.

(ex. WHERE 절에서 ‘=’을 사용했을 때)

인덱스 범위 스캔의 경우, 당연하게도 하나의 데이터가 아닌 여러 개의 데이터를 추출할 때 사용한다.

# 궁금한 내용 / 부족한 내용

---

부족한 점 → 인덱스 스캔, 복합 인덱스? 칼럼의 순서에 따라 어떻게 인덱스에 접근하는지에 대한 자세한 내용

다음부터는 추가적으로 조사한 부분이다.

## 1. 인덱스는 어떨 때 적용해야 할까?

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/1436096a-883f-4572-9879-c1ea3ce60089/Untitled.png)

## 2. 왜 카디널리티가 높은 칼럼이 인덱스를 적용하기에 좋다고 하는 걸까?

먼저 카디널리티가 높다는 말은 칼럼값의 중복도가 낮다는 것을 뜻한다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/2ef06106-4ee4-4d65-909c-c3daf100713d/Untitled.png)

카디널리티가 높다.

→ 중복된 값이 많이 없다.

→ 특정 조건으로 데이터를 찾을 때, 더 작은 데이터 집합이 반환된다.

→ 전체 쿼리 처리 시간을 단축시키고 성능이 향상된다.

와 같은 논리 구조로 진행된다.

## 3. INSERT / UPDATE / DELETE 가 빈번할 때 인덱스 적용이 비효율적인 이유는?

- INSERT → 본래 인덱스에 있던 페이지에는 데이터가 들어갈 자리가 없다. 따라서 분할해서 새로운 데이터를 넣어야 하는데 이것은 성능에 영향을 준다.

- DELETE → 인덱스에서는 데이터를 실제로 제거하지 않는다. 다만 “사용하지 않음” 표시를 한다. DELETE 작업을 해도 인덱스 상에서 자리는 계속 차지하고 있다는 뜻이다.

- UPDATE → DELETE와 INSERT 작업이 함께 진행된다. 거의 비효율의 끝판왕

→ 결론적으로는 인덱스의 조각화가 심해지고 성능 저하가 일어나므로 되도록이면 조회 작업만이 일어나는 칼럼에 적용시키는 것이 좋다. (ex. 주민번호 → 수정될 일도 없고 조회는 많이 하는데 카디널리티도 높음)

# 느낀점

ㅋㅋㅋ아 인덱스는 진짜 처음 볼 때는 걍 뭔 소린지 감이 안 왔는데 역시 2번째 보니까 뭔가 팍팍 꽂히는 것 같다. 그리고 테코톡 영상을 보고 오니까 이해가 더 잘된다.

그리고 이 부분은 확실히 DB 설계같은 거 진행할 때, 칼럼을 어떤 순서로 놔야 하는지, 또 어떤 제약조건을 걸어놔야 하는지에 대해 심오한 고민을 하게 만드는 부분이라서 더 신중하게 생각하고 배우게 되는 것 같다.

아 재밌당 근데 아직 기본 내용이라서 그런지 설명이 뭔가 탈모온 것 마냥 듬성듬성 빠져있다. 추가 조사할 게 좀 많아서 다 못했는데 다음에 인덱스 챕터 왔을 때 더더더 자세하게 조사해봐야할 것 같다.