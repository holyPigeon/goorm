# 공부한 내용

---

## 1. SQL 처리과정

과거에는 SQL의 데이터 처리 과정을 프로그래머가 직접 작성해야 헀지만, 지금은 옵티마이저가 이 부분을 담당하기 때문에 직접 짜지 않아도 된다. (옵티마이저가 짠 실행 계획에 의해 처리된다.)

실행 계획이 만들어지는 과정은 크게 SQL 파싱, SQL 최적화로 나눌 수 있다.

### SQL 파싱

- SQL 파싱은 다음과 같은 순서로 처리된다.
  - SQL에 문법적으로 문제가 없는지 확인한다.
  - SQL에 의미적으로 문제가 없는지 확인한다. (권한이 없는 것은 아닌지, 존재하지 않는 테이블은 아닌지)
  - 해당 SQL과 실행계획이 라이브러리 캐시에 캐싱되었는지 확인한다.

- 파싱의 종류는 다음과 같다.
  - 소프트 파싱(Soft Parsing) : SQL과 실행계획을 캐시에서 찾아 곧바로 실행단계로 넘어가는 경우를 말함
  - 하드 파싱(Hard Parsing) : SQL과 실행계획을 캐시에서 찾지 못해 최적화 과정을 거치고 나서 실행단계로 넘어가는 경우를 말함

### SQL 최적화

SQL 최적화란 무엇일까. 말 그대로 사용자가 요청한 SQL을 최적의 처리경로로 처리해주는 작업이다.

하지만 이러한 처리경로는 그냥 나오는 것이 아니며, 옵티마이저가 부지런히 실행계획들을 생성하고 평가한 후에 나오게 된다. 경우의 수가 늘수록 작업이 굉장히 무거워지기 때문에 하드 파싱이라고 부른다.

이렇게 무거운 작업을 매번 할 수는 없기 때문에, “이 SQL에 대해서는 이 실행계획이 Best였다” 라는 경험을 캐싱을 통해 누적시키고, 추후 동일한 작업에 대해서는 캐싱된 실행계획을 사용하게 되는데 이것이 소프트 파싱이다.

## 2. 캐싱된 SQL 공유

### 실행계획 공유 조건

하드 파싱을 반복하지 않고 캐싱된 버전을 찾아 재사용하려면 캐시에서 SQL을 먼저 찾아야 한다.

이 때, 캐시에서 SQL을 찾기 위해 사용되는 키 값이 “SQL 문장 그 자체”이다. 결과적으로 같은 의미일지라도, 중간에 작은 공백 하나라도 들어가면 DBMS는 해당 문장을 다른 문장으로 인식한다.

### 실행계획을 공유하지 못하는 경우

다음과 같은 케이스들은 모두 다른 SQL로 인식한다.

- 공백 문자 또는 줄바꿈
  - SELECT * FROM CUSTOMER;SELECT * FROM CUSTOMER;
- 대소문자 구분
  - SELECT * FROM CUSTOMER; SELECT * FROM Customer;
- 주석(Comment)
  - SELECT * FROM CUSTOMER; SELECT /* 주석문 */ * FROM CUSTOMER;
- 테이블 Owner 명시
  - SELECT * FROM CUSTOMER; SELECT * FROM HR.CUSTOMER;
- 옵티마이져 힌트 사용
  - SELECT * FROM CUSTOMER; SELECT /*+ all_rows */ * FROM CUSTOMER;
- 조건절 비교 값
  - SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'tommy';
  - SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'karajan';
  - SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'javaking';
  - SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'oraking';

그냥 단 한 글자라도 틀리지 말고 똑같이 써야 캐싱된 실행계획을 활용함으로써 자원을 아낄 수 있다.

개발 초기에 SQL 표준을 정해두는 것도 방법이며, 특히 6번 조건절 비교 값의 경우 라이브러리 캐시 효율적으로 매우 안 좋은 상황이 발생할 수 있기 때문에 조심하는 것이 좋다.

(6번과 같은 경우를 리터럴 SQL이라 부른다)

## 3. 바인드 변수 사용하기

### 바인드 변수의 중요성

위 6번과 같은 방식으로는 프로시저가 하나씩 만들어져서 비효율적인데, 이를 파라미터 Driven 방식인 바인드 변수를 사용해 하나의 프로시저를 공유하게 함으로써 이용 가능하다.

다음과 같이 바인드 변수를 사용함으로써 같은 기능을 하는 프로시저의 중복을 피할 수 있다.

```java
SELECT * FROM CUSTOMER WHERE LOGIN_ID = :LOGIN_ID;
```

> 여기서 위 6번과 같은 방식이 왜 리터럴 SQL인지를 알 수 있었다.
변수를 사용하지 않고, 리터럴, 말 그대로의 문자열을 사용하여 비효율 적이기 때문에 리터럴 SQL이라고 부른다.
>

바인드 변수의 효과는 동시 사용자가 많아질 때, 그 효과가 절대적이다! 가끔씩 바인드 변수를 안 쓰는 경우도 있긴 하지만, 웬만하면 그냥 쓰는 것이 좋다.








