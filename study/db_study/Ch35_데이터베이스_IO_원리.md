# 공부한 내용

데이터베이스 I/O에 대해 알아보고, I/O를 효율화하는 방법 및 버퍼 캐시를 최적화하는 방법에 대해 알아보자!

## 1. 블록 I/O

모든 DBMS에서 I/O는 블록 단위로 이루어지며, SQL 성능을 좌우하는 가장 중요한 성능지표 또한 엑세스하는 블록의 개수이다.

- 아래의 모든 행위는 블록 단위로 이루어진다.
  - 데이터 파일에서 DB 버퍼 캐시로 블록을 적재할 때
  - 데이터 파일에서 블록을 직접 읽고 쓸 때
  - 버퍼 캐시에서 블록을 읽고 쓸 때
  - 버퍼 캐시에서 변경된 블록을 다시 데이터 파일에 쓸 때

## 2. **메모리 I/O vs. 디스크 I/O**

### I/O 효율화의 중요성

메모리 I/O와 디스크 I/O의 차이점!

일단 메모리 I/O는 디스크 I/O에 비해 속도가 매우 빠르다. 디스크 I/O는 엑세스 암(arm)을 움직여야 하는 반면 메모리 I/O는 전기적 신호에 불과하기 때문이다.

그럼 모든 I/O를 메모리에서 처리하면 안되는 걸까? 물론 그렇게 하면 좋겠지만, 비용적/기술적 한계가 있기 때문에 결국에는 디스크를 사용해야 한다.

(16기가 RAM과 16기가 USB의 가격을 비교해본다면 왜 안 되는지 알 것 같다. RAM이 훨씬 비싸다 ㅋㅋ)

결국에 디스크를 사용해야 하는 것은 맞지만, 그래도 디스크에 가기 전 버퍼 캐시에서의 효율을 최대한으로 올리면 디스크에 접근할 일이 적어짐으로써 성능을 향상시킬 수 있다.

### 버퍼 캐시 히트율**(Buffer Cache Hit Ratio)(=BCHR)**

버퍼 캐시의 효율을 측정하는 지표이다. 전체 읽은 블록 중 버퍼 캐시에서 읽은 블록은 몇 %인지 비율을 나타낸다.

당연하게도 BCHR이 높을수록 버퍼캐시 효율이 좋고 성능도 좋으며, BHCR 낮을수록 버퍼캐시 효율이 낮고 성능도 낮다.

다만 BCHR은 성능상의 절대적인 지표는 아니다. 결국 I/O를 가장 효율적으로 튜닝하려면 “논리적인 블록 요청 횟수”를 줄이고, “물리적으로 디스크에서 읽는 블록의 개수”를 줄이는 것이 핵심인데, 블록 요청 횟수가 높더라도 BCHR 또한 높게 나올 수 있기 때문이다.

(이 경우에는 래치(Latch) 경합 및 버퍼 Lock 경합으로 인해 메모리 I/O 비용이 디스크 I/O 비용보다 커질 수도 있다.)

### **네트워크, 파일시스템 캐시가 I/O 효율에 미치는 영향**

네트워크

네트워크 속도 및 전송량에 따라 I/O 효율이 달라진다.

이는 특히 클러스터링 환경에서 중요한데, 여러 개의 인스턴스가 있는 경우 공통된 DB 자원을 사용하며, 이 때 데이터 블록을 공유하고 동기화해야하기 때문에 그 과정에서 네트워크의 성능이 매우 중요하다.

파일시스템 버퍼 캐시

또한 파일시스템 캐시 또한 I/O 효율에 영향을 미친다. SAN 캐시는 커지더라도 상관이 없지만, 파일시스템 버퍼 캐시의 경우 너무 커지면 부작용이 있다.

애초에 DB 상에는 가장 효율적인 방법으로 데이터를 처리하도록 이미 캐싱 매커니즘이 준비되어 있는데, 괜히 그 위에 파일시스템 캐시를 둬서 미리 캐시 처리를 해버리면, DB 캐시를 100% 활용하지 못해 비효율이 생기는 상황이 발생할 수 있다.

결국 반복되는 얘기지만, 최대한 효율적인 SQL과 처리시스템을 통해 논리적인 블록 요청의 횟수를 줄이는 것이 가장 중요하다.

## **3. Sequential I/O vs. Random I/O**

Sequential I/O는 말 그대로 순차적으로 읽는 방법, Random I/O는 랜덤으로 읽는 방법이다. Sequential 액세스의 비중을 높여야 하며, Random 액세스는 줄여야한다.

### **Sequential 액세스에 의한 선택 비중 높이기**

Sequential 엑세스의 효율성을 높이기 위해 다음과 같은 방법을 제시하고 있다.

> 읽은 총 건수 중에서 결과집합으로 선택되는 비중을 높여야 한다.
>

말은 굉장히 어렵지만 요약하면 다음과 같다.

→ 최대한 적은 집합을 검색해서, 최대한 많은 결과집합을 선택한다.

ex. **`object_name = 'ALL_OBJECTS'`** 와 같은 조건을 사용하여 Table Full Scan을 한다 치면 49,906개의 레코드 중 단 1개만이 결과집합으로 선택되므로 이 때의 선택비중은 단 0.002%에 불과하다.

→ 굉장히 비효울적이다.

위와 같은 경우에서는 인덱스를 사용한 최적화를 통해 선택비중을 크게 늘리고, Squential 엑세스의 효율성을 높일 수 있다.












