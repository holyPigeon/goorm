# 공부한 내용

데이터베이스 I/O에 대해 알아보고, I/O를 효율화하는 방법 및 버퍼 캐시를 최적화하는 방법에 대해 알아보자!

## 1. 블록 I/O

모든 DBMS에서 I/O는 블록 단위로 이루어지며, SQL 성능을 좌우하는 가장 중요한 성능지표 또한 엑세스하는 블록의 개수이다.

- 아래의 모든 행위는 블록 단위로 이루어진다.
  - 데이터 파일에서 DB 버퍼 캐시로 블록을 적재할 때
  - 데이터 파일에서 블록을 직접 읽고 쓸 때
  - 버퍼 캐시에서 블록을 읽고 쓸 때
  - 버퍼 캐시에서 변경된 블록을 다시 데이터 파일에 쓸 때

## 2. **메모리 I/O vs. 디스크 I/O**

### I/O 효율화의 중요성

메모리 I/O와 디스크 I/O의 차이점!

일단 메모리 I/O는 디스크 I/O에 비해 속도가 매우 빠르다. 디스크 I/O는 엑세스 암(arm)을 움직여야 하는 반면 메모리 I/O는 전기적 신호에 불과하기 때문이다.

그럼 모든 I/O를 메모리에서 처리하면 안되는 걸까? 물론 그렇게 하면 좋겠지만, 비용적/기술적 한계가 있기 때문에 결국에는 디스크를 사용해야 한다.

(16기가 RAM과 16기가 USB의 가격을 비교해본다면 왜 안 되는지 알 것 같다. RAM이 훨씬 비싸다 ㅋㅋ)

결국에 디스크를 사용해야 하는 것은 맞지만, 그래도 디스크에 가기 전 버퍼 캐시에서의 효율을 최대한으로 올리면 디스크에 접근할 일이 적어짐으로써 성능을 향상시킬 수 있다.

### 버퍼 캐시 히트율**(Buffer Cache Hit Ratio)(=BCHR)**

버퍼 캐시의 효율을 측정하는 지표이다. 전체 읽은 블록 중 버퍼 캐시에서 읽은 블록은 몇 %인지 비율을 나타낸다.

당연하게도 BCHR이 높을수록 버퍼캐시 효율이 좋고 성능도 좋으며, BHCR 낮을수록 버퍼캐시 효율이 낮고 성능도 낮다.

다만 BCHR은 성능상의 절대적인 지표는 아니다. 결국 I/O를 가장 효율적으로 튜닝하려면 “논리적인 블록 요청 횟수”를 줄이고, “물리적으로 디스크에서 읽는 블록의 개수”를 줄이는 것이 핵심인데, 블록 요청 횟수가 높더라도 BCHR 또한 높게 나올 수 있기 때문이다.

(이 경우에는 래치(Latch) 경합 및 버퍼 Lock 경합으로 인해 메모리 I/O 비용이 디스크 I/O 비용보다 커질 수도 있다.)

### **네트워크, 파일시스템 캐시가 I/O 효율에 미치는 영향**

네트워크

네트워크 속도 및 전송량에 따라 I/O 효율이 달라진다.

이는 특히 클러스터링 환경에서 중요한데, 여러 개의 인스턴스가 있는 경우 공통된 DB 자원을 사용하며, 이 때 데이터 블록을 공유하고 동기화해야하기 때문에 그 과정에서 네트워크의 성능이 매우 중요하다.

파일시스템 버퍼 캐시

또한 파일시스템 캐시 또한 I/O 효율에 영향을 미친다. SAN 캐시는 커지더라도 상관이 없지만, 파일시스템 버퍼 캐시의 경우 너무 커지면 부작용이 있다.

애초에 DB 상에는 가장 효율적인 방법으로 데이터를 처리하도록 이미 캐싱 매커니즘이 준비되어 있는데, 괜히 그 위에 파일시스템 캐시를 둬서 미리 캐시 처리를 해버리면, DB 캐시를 100% 활용하지 못해 비효율이 생기는 상황이 발생할 수 있다.

결국 반복되는 얘기지만, 최대한 효율적인 SQL과 처리시스템을 통해 논리적인 블록 요청의 횟수를 줄이는 것이 가장 중요하다.

## **3. Sequential I/O vs. Random I/O**

Sequential I/O는 말 그대로 순차적으로 읽는 방법, Random I/O는 랜덤으로 읽는 방법이다. Sequential 액세스의 비중을 높여야 하며, Random 액세스는 줄여야한다.

### **Sequential 액세스에 의한 선택 비중 높이기**

Sequential 엑세스의 효율성을 높이기 위해 다음과 같은 방법을 제시하고 있다.

> 읽은 총 건수 중에서 결과집합으로 선택되는 비중을 높여야 한다.
>

말은 굉장히 어렵지만 요약하면 다음과 같다.

→ 최대한 적은 집합을 검색해서, 최대한 많은 결과집합을 선택한다.

ex. **`object_name = 'ALL_OBJECTS'`** 와 같은 조건을 사용하여 Table Full Scan을 한다 치면 49,906개의 레코드 중 단 1개만이 결과집합으로 선택되므로 이 때의 선택비중은 단 0.002%에 불과하다.

→ 굉장히 비효울적이다.

위와 같은 경우에서는 인덱스를 사용한 최적화를 통해 선택비중을 크게 늘리고, Squential 엑세스의 효율성을 높일 수 있다.

### Random 엑세스 발생량 줄이기

인덱스를 이용하더라도 해당 인덱스가 완벽하게 최적화되지 않았다면 Random 엑세스가 크게 발생하는 경우가 있으므로, 적절한 칼럼을 가진 인덱스를 생성하고 이용하는 것이 좋다.

## 4. **Single Block I/O vs. MultiBlock I/O**

1. Single Block I/O는 I/O Call 한 번에 하나의 데이터 블록만 읽어 메모리에 적재하는 방식
2. MultiBlock I/O는 I/O Call이 필요한 시점에, 인접한 블록들을 같이 읽어 메모리에 적재하는 방식

   을 뜻한다.


Table Full Scan 시에는 MultiBlock I/O 방식이 유리하며, 인덱스 스캔 시에는 Single Block I/O 방식이 유리하다.

인덱스 스캔 시에 MultiBlock I/O 방식을 사용하지 않는 이유는, 인덱스에 있는 블록들의 논리적인 순서가 실제 물리적인 순서와는 차이가 있기 때문이다.

(보기에는 붙어있는 것처럼 보이지만, 사실은 많이 떨어져있을 수도 있다는 얘기다.)

## 5. **I/O 효율화 원리**

당연한 얘기지만 논리적인 I/O 요청 횟수를 최소화하는 튜닝도 가능하다.

- 다음과 같은 방법들이 존재한다.
  - 필요한 최소 블록만 읽도록 SQL 작성
  - 최적의 옵티마이징 팩터 제공
  - 필요하다면, 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도

### **필요한 최소 블록만 읽도록 SQL 작성**

동일 데이터에 대해서 중복으로 접근하는 것이 아닌, 필요한 데이터를 한 번만 뽑고 이를 최대한 활용하여 연산하는 것이 좋다.

(=불필요한 DB 접근을 최대한 줄인다.)

### **최적의 옵티마이징 팩터 제공**

- 전략적인 인덱스 구성
  - 전략적인 인덱스 구성은 가장 기본적인 옵티마이징 팩터다.
- DBMS가 제공하는 기능 활용
  - 인덱스 외에도 DBMS가 제공하는 다양한 기능을 적극적으로 활용한다. 인덱스, 파티션, 클러스터, 윈도우 함수 등을 적극 활용해 옵티마이저가 최적의 선택을 할 수 있도록 한다.
- 옵티마이저 모드 설정
  - 옵티마이저 모드(전체 처리속도 최적화, 최초 응답속도 최적화)와 그 외 옵티마이저 행동에 영향을 미치는 일부 파라미터를 변경해 주는 것이 도움이 될 수 있다.
- 통계정보
  - 옵티마이저에게 정확한 정보를 제공한다.

### **옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도**

옵티마이저가 아주 가끔은 생각만큼 최적의 실행계획을 세우지 못하는 경우도 있으므로, 이럴 때는 옵티마이저에게 직접 힌트를 줄 수 있다.

→ 솔직히 이런 상황이 있을까…?

## 결론

결국은… 전체적으로 최소한의 I/O를 통해 원하는 결과를 얻을 수 있도록 최적화된 SQL 쿼리를 짜고, 인덱스 설계를 잘 해야한다라는 얘기가 많은 것 같다.


