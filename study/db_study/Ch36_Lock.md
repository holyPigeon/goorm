# 공부한 내용

## 1. Lock 기본

### Lock이란?

DB에서는 데이터의 일관성, 무결성을 보장하기 위해 트랜잭션이란 하나의 처리 단위를 사용한다.

예를 들어 특정 칼럼값을 수정한다고 가정했을 때, 데이터 읽기 → 원래 있던 데이터 제거하기 → 수정할 값 삽입하기 등의 과정이 있는데, 이러한 일련의 과정 속에는 외부의 개입이 있어선 안되므로, 하나의 리소스가 다른 트랜잭션에 의해 동시에 조작되지 않도록 해당 리소스에 Lock을 걸게 된다.

### 공유 Lock과 배타 Lock

Lock의 종류에는 기본적으로 공유 Lock과 배타 Lock이 있다. 읽기 작업에서는 공유 락이 걸리고, 그 외의 작업에서는 배타 락이 걸린다.

- 공유 Lock과 배타 Lock의 기본적인 정의는 다음과 같다.
  - **공유 락(Shared Lock)**: 데이터를 읽기만 하는 경우, 다른 사용자도 동시에 데이터를 읽을 수 있도록 공유 락이 걸립니다. 하지만, 이 상태에서는 데이터의 수정이 불가능합니다.
  - **배타 락(Exclusive Lock)**: 데이터를 수정하기 위해서는 배타 락이 필요합니다. 배타 락이 걸린 데이터는 해당 트랜잭션만 접근할 수 있으며, 다른 트랜잭션은 해당 데이터를 읽거나 쓸 수 없습니다.

공유 Lock과 배타 Lock은 어떤 기준에 따라 적용하는 것일까? 바로 데이터의 일관성, 무결성을 해치는지에 따라 다르게 적용된다.

읽기 작업의 경우, 아무리 많은 트랜잭션에서 행하더라도 해당 데이터를 변경시키지는 않기 때문에 일관성 및 무결성을 해치지 않는다. → 공유 Lock을 적용한다.

그러나 읽기를 제외한 나머지 생성 / 수정 / 삭제 작업의 경우, 동시에 진행하면 데이터 일관성 및 무결성을 해치게 된다. → 배타 Lock을 적용한다.

블로킹

블로킹… 말 그대로 막힌 상태를 뜻한다. Lock 간의 경합이 일어나 이도저도 못하는 상황이다.

예를 들면 A라는 트랜잭션이 C라는 리소스에서 작업을 진행하면서 Lock을 걸었다라고 할 때, B라는 트랜잭션은 A가 커밋 or 롤백을 하기 전까지는 죽어도 C에 접근할 수 없다.

결국 Lock 경합이 일어나면 누군가는 기다려야 하고, 이는 곧 성능 저하로 이어진다. 이러한 상황을 막기 위한 방법들을 살펴보자.

- 공유 Lock과 배타 Lock 사이의 경합이 제일 많으므로, 공유 Lock을 되도록 사용하지 않는다.

  (Oracle의 경우 이게 디폴트)

- 불필요하게 트랜잭션을 길게 정의하지 않음으로써 최대한 경합이 생길 상황을 막는다.
- “같은 리소스에 동시에 접근하는 짓”은 최대한 트래픽이 적은 시간에 하자.
- 만약 동시 접근이 불가피하다면, “Lock Time Out” 등을 설정함으로써 사용자가 너무 많은 시간을 기다리지 않도록 조치하자.
- Lock 레벨을 너무 상향 조정하지 말자.
- 애초에 가장 빨리 처리될만한 최적화 SQL을 사용하면 사실 Lock 경합을 걱정할 일이 줄어든다.




















