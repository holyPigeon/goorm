# 공부한 내용

## 1. Lock 기본

### Lock이란?

DB에서는 데이터의 일관성, 무결성을 보장하기 위해 트랜잭션이란 하나의 처리 단위를 사용한다.

예를 들어 특정 칼럼값을 수정한다고 가정했을 때, 데이터 읽기 → 원래 있던 데이터 제거하기 → 수정할 값 삽입하기 등의 과정이 있는데, 이러한 일련의 과정 속에는 외부의 개입이 있어선 안되므로, 하나의 리소스가 다른 트랜잭션에 의해 동시에 조작되지 않도록 해당 리소스에 Lock을 걸게 된다.

### 공유 Lock과 배타 Lock

Lock의 종류에는 기본적으로 공유 Lock과 배타 Lock이 있다. 읽기 작업에서는 공유 락이 걸리고, 그 외의 작업에서는 배타 락이 걸린다.

- 공유 Lock과 배타 Lock의 기본적인 정의는 다음과 같다.
  - **공유 락(Shared Lock)**: 데이터를 읽기만 하는 경우, 다른 사용자도 동시에 데이터를 읽을 수 있도록 공유 락이 걸립니다. 하지만, 이 상태에서는 데이터의 수정이 불가능합니다.
  - **배타 락(Exclusive Lock)**: 데이터를 수정하기 위해서는 배타 락이 필요합니다. 배타 락이 걸린 데이터는 해당 트랜잭션만 접근할 수 있으며, 다른 트랜잭션은 해당 데이터를 읽거나 쓸 수 없습니다.

공유 Lock과 배타 Lock은 어떤 기준에 따라 적용하는 것일까? 바로 데이터의 일관성, 무결성을 해치는지에 따라 다르게 적용된다.

읽기 작업의 경우, 아무리 많은 트랜잭션에서 행하더라도 해당 데이터를 변경시키지는 않기 때문에 일관성 및 무결성을 해치지 않는다. → 공유 Lock을 적용한다.

그러나 읽기를 제외한 나머지 생성 / 수정 / 삭제 작업의 경우, 동시에 진행하면 데이터 일관성 및 무결성을 해치게 된다. → 배타 Lock을 적용한다.

블로킹

블로킹… 말 그대로 막힌 상태를 뜻한다. Lock 간의 경합이 일어나 이도저도 못하는 상황이다.

예를 들면 A라는 트랜잭션이 C라는 리소스에서 작업을 진행하면서 Lock을 걸었다라고 할 때, B라는 트랜잭션은 A가 커밋 or 롤백을 하기 전까지는 죽어도 C에 접근할 수 없다.

결국 Lock 경합이 일어나면 누군가는 기다려야 하고, 이는 곧 성능 저하로 이어진다. 이러한 상황을 막기 위한 방법들을 살펴보자.

- 공유 Lock과 배타 Lock 사이의 경합이 제일 많으므로, 공유 Lock을 되도록 사용하지 않는다.

  (Oracle의 경우 이게 디폴트)

- 불필요하게 트랜잭션을 길게 정의하지 않음으로써 최대한 경합이 생길 상황을 막는다.
- “같은 리소스에 동시에 접근하는 짓”은 최대한 트래픽이 적은 시간에 하자.
- 만약 동시 접근이 불가피하다면, “Lock Time Out” 등을 설정함으로써 사용자가 너무 많은 시간을 기다리지 않도록 조치하자.
- Lock 레벨을 너무 상향 조정하지 말자.
- 애초에 가장 빨리 처리될만한 최적화 SQL을 사용하면 사실 Lock 경합을 걱정할 일이 줄어든다.

교착 상태(DeadLock)

교착 상태는 블로킹보다 훨씬 심각한 상태다. 블로킹의 경우, 특정 트랜잭션의 처리가 완료되면 다른 트랜잭션이 접근할 수 있지만, 교착 상태의 경우 따로 조치를 해주지 않는 이상 영원히 진행이 되지 않는다.

교착 상태가 발생할 경우, DBMS는 한쪽 세션에 고의적으로 에러를 일으켜 문제를 해결하게 된다.

하지만 애초에 이러한 상황을 방지하려면, 위의 Lock 튜닝 방안을 이용하거나, 여러 테이블 접근 시에 접근 순서를 명시해주는 등의 조치가 필요하다.

## 2. Oracle Lock

오라클에서는 DML Lock, DDL Lock, 래치(Latch), 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 제공한다. 하지만 이 중에 가장 중요한 건 당연 DML Lock이다.

DML Lock에는 Row Lock과 Table Lock이 있다.

### Row Lock

모든 CRUD 작업에 대해 배타 Lock을 적용한다. 따라서 특정 트랜잭션이 커밋 or 롤백할 때까지 다른 트랜잭션은 해당 Row에 절대 접근할 수 없다.

추가로, 오라클은 “다중버전 동시성 제어” 기술을 통해 갱신과 읽기 작업간의 독립성을 보장하며, 충돌을 방지한다.

### Table Lock

한 트랜잭션이 Row Lock을 얻게 되면, 해당 테이블에 대한 Table Lock도 동시에 얻게 된다.

말만 들으면 테이블 전체에 Lock을 걸어 아무것도 못하게 할 것 같지만, 막상 그런 건 아니고 그냥 어떤 트랜잭션이 해당 테이블에서 어떤 작업을 하고 있는지에 대한 푯말같은 역할이다.

만약 다른 트랜잭션이 해당 테이블에서 작업을 하려고 하면, 푯말을 보고 충돌 여부를 확인한 후에 작업을 진행할 수 있다.

→ 세부적인 각 Lock 간의 호환성에 대한 내용이 있었지만 생략했다… 봐도 모를 것 같다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/f1e2ea8f-cc43-48b5-a6c0-029c0b94e9a4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.23.42.png)












