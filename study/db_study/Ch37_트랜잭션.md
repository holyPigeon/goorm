# 공부한 내용

## 들어가기 전에

트랜잭션이란 무엇일까? 트랜잭션(Transaction)은 업무 처리를 위한 논리적인 작업 단위다.

앞에서 많이 본 개념이긴 하지만 다시 설명해보겠다…

우리는 DB에서 기본적으로 CRUD를 포함, 여러가지의 작업을 수행하게 되는데, 이 중에는 중간에 간섭을 받으면 안되는, 만약 간섭을 받는다면 치명적인 오류가 발생하는 작업들이 존재한다.

예를 들면 수정 작업의 경우, 수정할 값을 사용자로부터 받고 → 기존 값을 지우고 → 수정할 값을 삽입하는 등의 일련의 작업이 필요한데, 중간에 생길 수 있는 피치못할 간섭을 방지하기 위해 해당 작업들을 하나의 “트랜잭션”이라는 단위로 묶는다.

트랜잭션으로 묶인 작업들은 중간까지만 실행되는 경우가 없으며, 무조건 커밋 or 롤백의 과정을 거친다.

## 1. 트랜잭션의 특징

- 다음과 같은 4가지 특징이 있다. 줄여서 ACID라고 부른다.
  - 원자성(Atomicity) → 트랜잭션은 더 이상 분해가 불가능한 업무의 최소단위이므로, 전부 처리되거나 아예 하나도 처리되지 않아야 한다.
  - 일관성(Consistency) → 일관된 상태의 데이터베이스에서 하나의 트랜잭션을 성공적으로 완료하고 나면 그 데이터베이스는 여전히 일관된 상태여야 한다. 즉, 트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 한다.
  - 격리성(Isolation) → 실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다.
  - 영속성(Durability) → 트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다.

## 2. 트랜잭션 격리성

트랜잭션의 격리성은 Lock의 강도에 따라 결정된다.

### 만약 격리성이 낮다면?

1. Dirty Read

   아직 트랜잭션이 완료되지 않았는데 해당 리소스에 다른 트랜잭션이 개입해 값을 읽는다면, 해당 트랜잭션은 비일관된 상태에 놓이게 된다.

2. Non-Repeatable Read

   한 트랜잭션 내에서 똑같은 작업을 2번 수행했는데, 그 사이에 다른 트랜잭션이 개입하여 앞뒤 결과가 달라지는 현상을 뜻한다.

### 트랜잭션 격리성의 수준

- 트랜잭션 격리성의 수준은 다음과 같이 분류된다.
  - Read Uncommitted(위험) → 트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다
  - Read Committed(보통) → 트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용함으로써 Dirty Read를 방지해준다. 커밋된 데이터만 읽더라도 Non-Repeatable Read와 Phantom Read 현상을 막지는 못한다. 읽는 시점에 따라 결과가 다를 수 있다는 것이다.
  - Repeatable Read(보통) → 트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌는 현상을 방지해 준다. 이 트랜잭션 격리성 수준이 Phantom Read 현상을 막지는 못한다. 첫 번째 쿼리에서 없던 새로운 레코드가 나타날 수 있다는 것이다.
  - Serializable Read(안전) → 트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않는다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/f83fffdd-b738-4052-8111-613973978e85/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.13.34.png)

대부분 DBMS가 Read Committed를 기본 트랜잭션 격리성 수준으로 채택하고 있으므로 Dirty Read가 발생할까 걱정하지 않아도 된다.

하지만 Non-Repeatable Read, Phantom Read 현상에 대해선 세심한 주의가 필요하다. 기본적으로 DBMS에서 관리해주는 부분이 있지만, 많은 경우에 개발자가 직접 신경써주어야 한다.

다중 트랜잭션 환경에서 DBMS가 제공하는 기능을 이용해 동시성을 제어하려면 트랜잭션 시작 전에 명시적으로 Set Transaction 명령어를 수행하기만 하면 된다.

```sql
// 트랜잭션 격리성 수준을 Serializable Read로 상향 조정
set transaction isolation level read serializable;
```

추가적으로, 대량의 데이터 처리 시에는 동시성이 심각하게 나빠지는데, DBMS에서는 이런 상황에 대비해서 다중버전 동시성 제어 기능을 제공한다.

# 궁금한 내용 / 부족한 내용

---

## 🤔 그냥 Lock을 높은 수준으로 걸면 안되는 걸까?

데이터를 최대한 안전하게 처리하려면 그냥 Lock을 최대한 높은 수준으로 걸면 되지 않을까라는 생각이 들어서 이에 대해 찾아보았다.

어느정도 예상할 수 있는 결과이지만, Lock을 심하게 걸면 걸수록 해당 리소스에 접근할 수 있는 트랜잭션의 수는 적어지고, 반대로 대기시간은 늘어난다.

사실상 가용한 트랜잭션들이 사용자가 설정한 규칙들에 막혀 쓰이지 못하는 상황이라 당연하게도 성능 저하가 발생하게 된다.

이러한 단점으로 인해 자료에서도 소개된 다중버전 동시성 제어 기능이 사용된다. 리소스에 대한 과거 기록을 스냅샷으로 따로 보관해둠으로써 굳이 다른 트랜잭션의 작업을 끝까지 지켜보지 않더라도 이를 참고해서 (대기시간 없이) 작업을 진행할 수 있다.


