# 공부한 내용

DBMS에서는 다수의 사용자가 접근할 때 통상적으로 Lock을 통해 동시성을 제어한다.

Lock이란 기능은 그 격리 정도가 높아질수록 데이터의 일관성을 유지하기 쉽지만, 반대로 많은 사용자들이 접근할 수 없기 때문에 동시성이 저하된다. 즉 일관성과 동시성이 Trade-Off 관계에 있다.

이러한 이유로 동시성 제어 기술에서 가장 중요한 목표는 데이터의 일관성을 유지하는 한에서 동시에 실행되는 트랜잭션의 수를 최대한으로 늘리는 것이다.

앞선 챕터에서 `set transaction` 명령어를 통한 동시성 제어 방법에 대해 설명했지만, n-Tier 아키텍처가 지배적인 최근 어플리케이션 환경에서는 이것만으로 동시성을 장담할 수 없기 때문에, 많은 경우에 개발자는 트랜잭션의 동시성을 직접 구현해야한다.

## 1. 비관적 동시성 제어 vs 낙관적 동시성 제어

### 비관적 동시성 제어

비관적 동시성 제어는 사용자들이 같은 데이터를 동시에 수정할 것이라 가정한다. 따라서 데이터를 읽는 시점에서 Lock을 걸고, 이를 트랜잭션 종료까지 유지한다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 
from 고객 
where 고객번호 = :cust_num 
for update;
```

하지만 읽기 시점에 Lock을 거는 행위는 동시성을 심각하게 저하시킬 수 있다. 따라서 wait 또는 nowait 옵션을 함께 사용해야한다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 
from 고객 
where 고객번호 = :cust_num 
for update nowait; // 다른 트랜잭션이 이미 락을 걸었을 때, 기다리지 않고 바로 예외 투척

select 적립포인트, 방문횟수, 최근방문일시, 구매실적 
from 고객 
where 고객번호 = :cust_num 
for update wait 3; // 다른 트랜잭션이 이미 락을 걸었을 때, 3초를 기다려보고 예외 투척
```

### 낙관적 동시성 제어

낙관적 동시성 제어는 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정한다. 따라서 데이터를 읽는 시점에 Lock을 걸지 않는다. 하지만 수정 시점에는 혹시 다른 트랜잭션에 의해 값이 변경된 것은 아닌지 반드시 검사해야 한다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 
into :a, :b, :c, :d 
from 고객 
where 고객번호 = :cust_num; 

-- 새로운 적립포인트 계산 
update 고객 
set 적립포인트 = :적립포인트 
where 고객번호 = :cust_num and 적립포인트 = :a and 방문횟수 = :b and 최근방문일시 = :c and 구매실적 = :d ; 
if sql%rowcount = 0 
	then alert('다른 사용자에 의해 변경되었습니다.'); 
end if;
```

사실 낙관적 동시성 제어란 것을 쓸 일이 있을까? 싶다. 애초에 개발이란 게 단 1%의 에러도 용납하지 않는 경우가 대부분인데 낙관적으로 개발을 한다는 것 자체가 좀… ㅋㅋㅋㅋ 그러다가 비관적인 상황이 생기면 어쩌려고..

## 2. 다중버전 동시성 제어

### 일반적인 Locking 매커니즘의 문제점

일반적인 Locking 매커니즘에서는 읽기 작업(공유 Lock)과 쓰기 작업(배타 Lock)이 서로 충돌을 일으켜 동시성, 데이터 일관성에 문제가 생기곤 한다.

이를 해결하려면 Lock의 수준을 높여야 하지만, Trade-Off로 동시성이 저하되기 때문에 반쪽짜리 해결법이다. 확실한 해결법은 다중버전 동시성 제어를 이용하는 것이다.

### 다중버전 동시성 제어

다중버전 동시성 제어의 원리는 간단하다.

1. 데이터가 변경될 때마다 해당 변경사항을 undo 영역에 저장한다.
2. 데이터를 읽다가 쿼리 or 트랜잭션 시작 이후에 변경된 데이터를 발견하면, undo 영역에서 정보를 찾아 시작 시점의 버전(CR copy)을 생성하고 읽는다.

이러한 방법을 사용하면, 변경이 진행중인 레코드를 만나더라도 해당 작업이 끝날 때까지 대기하지 않아도 되기 때문에 동시성 측면에서 매우 유리하다.

물론 Undo 블록 I/O, CR Copy 생성, CR 블록 캐싱 같은 작업으로 인해 부가적인 오버헤드가 생기곤 하지만, 이를 감안하더라도 동시성 & 일관성을 모두 향상시킬 수 있는 좋은 방법이다.

### MVCC를 이용한 읽기 일관성의 종류

- 문장수준의 읽기 일관성
    - SQL / 쿼리 수준에서 지켜지는 일관성이다.
    - MVCC에서는 완벽한 문장수준 읽기 일관성을 보장한다.

- 트랜잭션 수준의 읽기 일관성
    - 트랜잭션 수준에서 지켜지는 일관성이다.
    - 완벽한 트랜잭션 수준 일관성을 얻기 위해선 격리 레벨을 Serializable Read로 올려야 한다.

      (동시성 저하가 심하므로 사실상 쉽지 않다.)

### Snapshot too old?

MVCC가 매우 유용한 기능을 제공하는 만큼, 가끔은 “Snapshot too old”라는 에러가 발생할 때도 있다.

해당 에러 가능성을 최대한 줄이기 위한 조치들이 존재하지만, Too Deep한 관계로 넘어가도록 한다.

# 궁금한 내용 / 부족한 내용

## 🤔 어플리케이션 레벨에서 DB 동시성을 제어할 수 있는 방법은 없을까?

### 자바에서 동시성 제어하기

사실 아직까지는 DB 레벨에서 직접 락을 거는 작업이 어색하고, 더 편한 방법은 없을까 싶어서 자바 스프링을 통해 동시성을 제어할 수는 없을까라는 궁금증이 생겼다.

일단 방법은 있다. 기존 자바에서 동시성을 해결하기 위해 사용했던 `Synchronized` 라는 키워드가 있는데, 이것을 사용하면 된다.

하지만 추가적으로 조사해본 결과, 이 방법에는 치명적인 단점이 존재한다. `Synchronized` 의 경우 JVM 내에서만 동시성을 제어하기 때문에, 만약 여러 대의 서버가 동일한 DB에 접근하는 분산 처리 환경이라면 이러한 동시성 처리가 전혀 쓸모없어지게 된다.

따라서 어플리케이션에서 어떤 방법으로 동시성을 처리하든, 최종적으로 DB에서 제어를 해주지 않는 이상 분산 처리 환경에서 이슈가 생길 수밖에 없다.

# 궁금한 내용 / 부족한 내용

---

## 🤔 어플리케이션 레벨에서 DB 동시성을 제어할 수 있는 방법은 없을까?

### 자바에서 동시성 제어하기

사실 아직까지는 DB 레벨에서 직접 락을 거는 작업이 어색하고, 더 편한 방법은 없을까 싶어서 자바 스프링을 통해 동시성을 제어할 수는 없을까라는 궁금증이 생겼다.

일단 방법은 있다. 기존 자바에서 동시성을 해결하기 위해 사용했던 `Synchronized` 라는 키워드가 있는데, 이것을 사용하면 된다.

하지만 추가적으로 조사해본 결과, 이 방법에는 치명적인 단점이 존재한다. `Synchronized` 의 경우 JVM 내에서만 동시성을 제어하기 때문에, 만약 여러 대의 서버가 동일한 DB에 접근하는 분산 처리 환경이라면 이러한 동시성 처리가 전혀 쓸모없어지게 된다.

따라서 어플리케이션에서 어떤 방법으로 동시성을 처리하든, 최종적으로 DB에서 제어를 해주지 않는 이상 분산 처리 환경에서 이슈가 생길 수밖에 없다.

### 보다 편한 방법

그렇다고 방법이 전혀 없는 것은 아니고, 원하는 메소드에 `@Transactional` 어노테이션을 사용하면 해당 메소드가 DB의 하나의 트랜잭션 내에서 처리되어야한다는 걸 보장해줌으로써 동시성을 제어할 수 있다.

해당 어노테이션에는 isolation이라는 속성이 존재하는데, 해당 속성에

- Isolation.READ_UNCOMMITTED
- Isolation.READ_COMMITTED
- Isolation.REPEATABLE_READ
- Isolation.SERIALIZABLE

와 같이 앞에서 배웠던 격리 레벨을 그대로 설정할 수 있다. 만약 설정하지 않는다면 사용하는 DB의 디폴트값을 따른다.




