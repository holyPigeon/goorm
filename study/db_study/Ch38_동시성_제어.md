# 공부한 내용

DBMS에서는 다수의 사용자가 접근할 때 통상적으로 Lock을 통해 동시성을 제어한다.

Lock이란 기능은 그 격리 정도가 높아질수록 데이터의 일관성을 유지하기 쉽지만, 반대로 많은 사용자들이 접근할 수 없기 때문에 동시성이 저하된다. 즉 일관성과 동시성이 Trade-Off 관계에 있다.

이러한 이유로 동시성 제어 기술에서 가장 중요한 목표는 데이터의 일관성을 유지하는 한에서 동시에 실행되는 트랜잭션의 수를 최대한으로 늘리는 것이다.

앞선 챕터에서 `set transaction` 명령어를 통한 동시성 제어 방법에 대해 설명했지만, n-Tier 아키텍처가 지배적인 최근 어플리케이션 환경에서는 이것만으로 동시성을 장담할 수 없기 때문에, 많은 경우에 개발자는 트랜잭션의 동시성을 직접 구현해야한다.

## 1. 비관적 동시성 제어 vs 낙관적 동시성 제어

### 비관적 동시성 제어

비관적 동시성 제어는 사용자들이 같은 데이터를 동시에 수정할 것이라 가정한다. 따라서 데이터를 읽는 시점에서 Lock을 걸고, 이를 트랜잭션 종료까지 유지한다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 
from 고객 
where 고객번호 = :cust_num 
for update;
```

하지만 읽기 시점에 Lock을 거는 행위는 동시성을 심각하게 저하시킬 수 있다. 따라서 wait 또는 nowait 옵션을 함께 사용해야한다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 
from 고객 
where 고객번호 = :cust_num 
for update nowait; // 다른 트랜잭션이 이미 락을 걸었을 때, 기다리지 않고 바로 예외 투척

select 적립포인트, 방문횟수, 최근방문일시, 구매실적 
from 고객 
where 고객번호 = :cust_num 
for update wait 3; // 다른 트랜잭션이 이미 락을 걸었을 때, 3초를 기다려보고 예외 투척
```

### 낙관적 동시성 제어

낙관적 동시성 제어는 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정한다. 따라서 데이터를 읽는 시점에 Lock을 걸지 않는다. 하지만 수정 시점에는 혹시 다른 트랜잭션에 의해 값이 변경된 것은 아닌지 반드시 검사해야 한다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 
into :a, :b, :c, :d 
from 고객 
where 고객번호 = :cust_num; 

-- 새로운 적립포인트 계산 
update 고객 
set 적립포인트 = :적립포인트 
where 고객번호 = :cust_num and 적립포인트 = :a and 방문횟수 = :b and 최근방문일시 = :c and 구매실적 = :d ; 
if sql%rowcount = 0 
	then alert('다른 사용자에 의해 변경되었습니다.'); 
end if;
```

사실 낙관적 동시성 제어란 것을 쓸 일이 있을까? 싶다. 애초에 개발이란 게 단 1%의 에러도 용납하지 않는 경우가 대부분인데 낙관적으로 개발을 한다는 것 자체가 좀… ㅋㅋㅋㅋ 그러다가 비관적인 상황이 생기면 어쩌려고..

## 2. 다중버전 동시성 제어

### 일반적인 Locking 매커니즘의 문제점

일반적인 Locking 매커니즘에서는 읽기 작업(공유 Lock)과 쓰기 작업(배타 Lock)이 서로 충돌을 일으켜 동시성, 데이터 일관성에 문제가 생기곤 한다.

이를 해결하려면 Lock의 수준을 높여야 하지만, Trade-Off로 동시성이 저하되기 때문에 반쪽짜리 해결법이다. 확실한 해결법은 다중버전 동시성 제어를 이용하는 것이다.














