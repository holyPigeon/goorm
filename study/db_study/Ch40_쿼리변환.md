# 공부한 내용

## 1. 쿼리변환이란?

쿼리변환이란, 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 뜻한다. 이는 Query Transformer가 수행한다.

→ 사용자 SQL을 최적화에 유리한 형태로 재작성한다.

## 2. 서브쿼리 Unnesting

“서브쿼리 Unnesting”은 중첩된 서브쿼리를 풀어내는 것을 말한다.

중첩된 서브쿼리는 메인쿼리와 부모와 자식이라는 종속적, 계층적인 관계가 존재한다. 정석적인 방법으로 해당 쿼리를 읽으려면 필터 방식을 사용해야 해야하는데, 이 방식은 가끔은 비효율적일 때도 있다.

- 이에 따라 옵티마이저는 중첩된 서브쿼리를 다음과 같이 최적화한다
    - 서브쿼리 Unnesting을 사용한다 → 동일한 결과를 보장하는 조인문으로 변환하고 나서 최적화한다.
    - 서브쿼리 Unnesting을 사용하지 않는다 → 메인쿼리와 서브쿼리를 별도의 서브플랜으로 구분해서 각각 최적화를 진행한다. 이 떄, 서브쿼리에선 필터 오퍼레이션이 진행된다.

**보통은 Unnesting을 하는 쪽이 더 다양한 실행계획을 세우고, 최적화가 잘될 가능성이 크다.** 하지만 항상 그렇지는 않기 때문에 최신 DBMS에서는 2가지 방법을 비교해보고 나은 쪽을 선택한다.

(그럼에도 불구하고 기계는 완벽하지 않기 때문에 개발자가 직접 힌트를 통해 처리에 관여할 때도 있다.)

## 3. 뷰 Merging

```sql
select * 
from 
	(select * 
	 from emp 
	 where job = 'SALESMAN') a , 
	 
	(select * 
	from dept 
	where loc = 'CHICAGO') b 
where a.deptno = b.deptno;
```

위와 같은 인라인 뷰, 그리고 서브쿼리는 사람 눈에는 보기 편하지만, 옵티마이저 입장에서는 파싱하기에 상당히 불편한 구조이다. 그래서 옵티마이저는 처리 과정에서 블록을 풀어내려고 한다.

따라서 위 쿼리는 아래와 같이 바뀌며, 이 과정을 뷰 Merging이라고 한다.

```sql
select * 
from emp a, dept b 
where a.deptno = b.deptno and a.job = 'SALESMAN' and b.loc = 'CHICAGO'
```

일반적으로 단순한 뷰는 Merging하더라도 성능 저하가 없지만, 복잡한 뷰의 경우 성능 저하가 생길 수 있다.

이 역시 DBMS 측에서 뷰 Merging을 진행했을 때 성능 저하가 발생하는지 여부를 판단하기도 하지만, 역시 기계는 완벽하지 않기 때문에 개발자가 힌트를 사용해야 할 경우가 있다.

- 아래는 뷰 Merging이 불가능한 경우이다.
    - 집합(set) 연산자(union, union all, intersect, minus)
    - connect by절
    - ROWNUM pseudo 칼럼
    - select-list에 집계 함수(avg, count, max, min, sum) 사용
    - 분석 함수(Analytic Function)















