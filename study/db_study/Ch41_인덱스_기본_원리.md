# 공부한 내용

인덱스는 무엇일까? 인덱스는 데이터를 빠르게 탐색하기 위한 수단이며, 간단하게 비유하자면 책에서의 맨 앞 목차라고 할 수 있다.

## 1. 인덱스 구조

### 인덱스 구조

사실 뭐 구조야 많을 수 있지만 인덱스에서는 그냥 B 트리 구조만 알고가면 된다.

말 그대로 트리구조이며, 이름이 B 트리인 이유는 Balanced Tree이기 때문이다. B 트리 구조는 루트, 브랜치, 리프 노드로 이루어져 있으며, 각 리프 노드는 양방향으로 연결되어있다.

### 인덱스 탐색

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.

- 각각 다음을 의미한다.
  - 수평적 탐색 → 리프 노드끼리 이동
  - 수직적 탐색 → 루트에서 리프 노드로 이동

## 2. 다양한 인덱스 스캔 방식

### Index Range Scan

인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위(Range)만 스캔하는 방식이다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_331.jpg)

B Tree 인덱스의 가장 일반적이고 정상적인 형태의 엑세스 방식이다. 인덱스의 범위 스캔은 인덱스를 구성하는 선두 컬럼을 조건절에 사용하는 등의 방법을 통해 가능하다.

### Index Full Scan

수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다. 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택된다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_332.jpg)

어쨌든간에 Full Scan 방식이기 때문에 아주 효율적인 방식은 아니다. 하지만 그럼에도 Table Full Scan 보다는 효율적일 수 있다.

조건절이 없는 쿼리에서는 Table Full Scan을 우선적으로 고려할 수밖에 없는데, 만약 Index Full Scan을 이용해 대부분의 데이터를 필터링할 수 있다면, Table Full Scan보다 비용이 적다.

### Index Unique Scan

수직적 탐색만으로 데이터를 찾는 스캔 방식으로서, Unique 인덱스를 ‘=’ 조건으로 탐색하는 경우에 작동한다. 특정 값에 대해 매우 빠르고 정확하게 접근한다는 특징이 있다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_335.jpg)

### Index Skip Scan

앞에서는 인덱스 선두 칼럼이 조건절에 빠지면 Index Full Scan을 사용할 수 있다고 설명했다.

최근에는 이러한 조건절에 빠졌어도 인덱스를 활용할 수 있는 새로운 스캔방식이 나왔는데 Index Skip Scan이 바로 그것이다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_336.jpg)

기본적으로 조건에 부합하는 레코드를 포함할 “가능성이 있는” 하위 블록(브랜치 또는 리프 블록)만 골라서 액세스하는 방식이다.

### Index Fast Full Scan

Index Full Scan 보다 빠른 전체 스캔 방식이다. 더 빠른 이유는, 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식으로 스캔하기 때문이다.

다음과 같은 차이점이 있다.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/3b43dd71-c23b-4fd5-9b5d-3dd510d1e1a4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.24.19.png)

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/5486ac02-837a-4340-b853-a8cd7b03f65f/b5c3aff6-85c9-4efd-a06d-7796e5d65583/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.24.22.png)

### **Index Range Scan Descending**

기본적인 Index Range Scan과 동일하나, 뒤에서 앞으로 스캔하므로 내림차순 정렬된 결과집합을 얻는다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_338.jpg)

## 3. 인덱스 종류

### B Tree 인덱스

기본적으로 B Tree 인덱스는 Balanced Tree 인덱스이기 때문에, 아래와 같이 한 쪽에 치우쳐진 형태는 절대 발생하지 않는다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_339.jpg)

하지만 구조 자체는 치우쳐져 있지 않더라도, 그 안의 키 값이라던가 엔트리는 치우쳐져 있을 수 있다. 아래와 같이 한 쪽 블록에 데이터가 몰아져 있다거나, 아니면 비어있는 블록이 많은 경우이다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_340.jpg)

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_341.jpg)

예를 들어 대량의 delete 작업이 진행된 경우, 인덱스에서는 블록을 아예 제거하지 않고 비워두게 된다. 이 블록은 추후에 데이터가 다시 들어오면 재사용될 수 있지만, 비어있더라도 인덱스를 사용할 때 똑같은 수의 블록을 스캔하기 때문에 비효율이 존재한다.

결국, 인덱스는 시간이 지날수록 데이터가 추가되고 제거되는 과정 속에서 점차 파편화가 진행되고, 점점 비효율적으로 변하게 된다.

이럴 때는 인덱스를 아예 제거하고 재생성해줘야 하는데, 인덱스 재생성도 상당히 부하가 많은 작업이기 때문에 다음과 같은 기준에 따라 진행한다.

- 인덱스 분할에 의한 경합이 현저히 높을 때
- 자주 사용되는 인덱스 스캔 효율을 높이고자 할 때. 특히 NL Join에서 반복 액세스되는 인덱스 높이(height)가 증가했을 때
- 대량의 delete 작업을 수행한 이후 다시 레코드가 입력되기까지 오랜 기간이 소요될 때
- 총 레코드 수가 일정한데도 인덱스가 계속 커질 때

### 비트맵 인덱스

비트맵 인덱스는 여러 인덱스를 동시에 활용할 수 있다는 장점 때문에 다양한 조건절이 사용되는, 특히 정형화되지 않은 임의 질의(ad-hoc query)가 많은 환경에 적합하다.

다만, 비트맵 인덱스는 Lock에 의한 DML 부하가 심한 것이 단점이다. 레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 Lock이 걸린다.

읽기 위주의 대용량 DW(특히, OLAP) 환경에 아주 적합하다.(데이터 분석쪽) OLTP 환경에서는 부적합하다.

### 함수기반 인덱스

칼럼 값 자체가 아닌, 칼럼에 특정 함수를 적용한 값으로 B*Tree 인덱스를 만든다.

### 리버스 키 인덱스

일련번호나 주문일시 같은 칼럼에 인덱스를 만들면, 입력되는 값이 순차적으로 증가하기 때문에 아래처럼 가장 오른쪽 리프 블록에만 데이터가 쌓인다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_343.jpg)

이러한 불균형을 해소하기 위해 리버스 키 인덱스를 사용할 수 있으며, 아래와 같이 트랜잭션을 고르게 분산시킨다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_344.jpg)

다만 데이터를 거꾸로 입력하는 특성 때문에 ‘=’ 조건으로만 검색이 가능하며, 부등호나 between, like 같은 범위검색 조건에는 사용할 수 없다.











