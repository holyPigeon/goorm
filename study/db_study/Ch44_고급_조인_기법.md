# 공부한 내용

## 1. 인라인 뷰 활용

대부분 조인은 1:M 관계인 테이블끼리의 조인이며, 조인 결과는 M쪽 집합과 같은 단위가 된다.

이를 다시 1쪽 집합 단위로 그룹핑해야 한다면 M쪽 집합을 먼저 1쪽 단위로 그룹핑하고 나서 조인하는 것이 유리하다. 조인 횟수를 줄여주며, 이 때 인라인 뷰를 사용할 수 있다.

## 2. 배타적 관계의 조인

어떤 엔터티가 두 개 이상의 다른 엔터티의 합집합과 관계(Relationship)를 갖는 것을 ‘상호배타적(Exclusive OR) 관계’라고 한다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_362.jpg)

위 예시의 경우, 테이블 구성 시

1. 작업지시를 개통신청 / 장애접수와 각각 따로 합쳐 만드는 경우가 있고
2. 하나의 테이블로 구성하고 작업 유형을 1(개통신청), 2(장애접수)로 나누는 경우가 있다.

1번의 경우 Outer 조인을 활용 가능하다.

2번의 경우는 union all 연산을 활용할 수 있다.

## 3. 부등호 조인

우리는 늘 ‘=’ 연산자를 이용한 조인에만 익숙해져 있지만 업무에 따라서는 between, like, 부등호 같은 연산자로 조인해야 할 때도 있다.

윈도우 함수가 지원되지 않는 DBMS일 경우, 부등호 조인을 사용할 수도 있다.

## 4. Between 조인

### 선분이력이란?

특정 테이블에서 변경이력을 관리할 때, 이력의 시작시점만을 기록하는 것을 “점이력 모델”이라고 하며, 시작과 종료시점을 모두 기록하는 것을 “선분이력 모델”이라 한다.

점이력 모델은 서브쿼리를 사용해야 하는 것과 달리, 선분이력 모델을 사용할 때는 쿼리가 간단해지는 장점이 있다. 쿼리가 짧아지면서 성능상 유리하긴 하지만, 꼭 장점만 있는 것은 아니다.

우선 이력이 추가될 때마다 기존 최종 이력의 종료일자(또는 종료일시)도 같이 변경해 주어야 하는 불편함과, 이 때문에 생기는 DML 부하를 고려해야 한다.

> PK를 어떻게 구성하느냐에 따라 다르지만 성능을 고려해 일반적으로 [ 마스터 키 + 종료일자 + 시작일자 ] 순으로 구성하곤 하는데, 이럴 경우 이력을 변경할 때마다 PK 값을 변경하는 셈이어서 RDBMS 설계 사상에 맞지 않다는 지적을 받곤 한다. 무엇보다, 개체 무결성을 완벽히 보장하기 어렵다는 것이 가장 큰 단점이다.
>

### 선분이력 기본조회 패턴

과거, 현재, 미래 임의 시점을 모두 조회할 수 있는 선분이력의 가장 기본적인 조회 패턴 쿼리는 다음과 같다.

```sql
select 연체개월수, 연체금액 
from 고객별연체금액 
where 고객번호 = :cust_num and :dt between 시작일자 and 종료일자
```

### 선분이력 조인

1. 과거/현재/미래의 임의 시점 조회

```sql
select c.고객번호, c.고객명, c1.고객등급, c2.전화번호 
from 고객 c, 고객등급변경이력 c1, 전화번호변경이력 c2 
where c.고객번호 = :cust_num and c1.고객번호 = c.고객번호 and c2.고객번호 = c.고객번호 and :dt 
between c1.시작일자 and c1.종료일자 and :dt 
between c2.시작일자 and c2.종료일자
```

1. 현재 시점 조회

```sql
select c.고객번호, c.고객명, c1.고객등급, c2.전화번호 
from 고객 c, 고객등급변경이력 c1, 전화번호변경이력 c2 
where c.고객번호 = :cust_num 
and c1.고객번호 = c.고객번호 
and c2.고객번호 = c.고객번호 
and c1.종료일자 = '99991231' 
and c2.종료일자 = '99991231'
```

### Between 조인

기존까지는 조회 시점이 정해져 있었지만, 미지의 거래일자 시점으로 선분이력을 조회하려면 between 조인이 필요하다.

```sql
select a.거래일자, a.종목코드, b.종목한글명, b.종목영문명, b.상장주식수 
, a.시가, a.종가, a.체결건수, a.체결수량, a.거래대금 
from 일별종목거래및시세 a, 종목이력 b 
where a.거래일자 
between to_char(add_months(sysdate, -20*12), 'yyyymmdd') 
and to_char(sysdate-1, 'yyyymmdd') and a.종가 = a.최고가 
and b.종목코드 = a.종목코드 
and a.거래일자 
between b.시작일자 
and b.종료일자
```

## 5. ROWID 활용

선분이력과 대비해, 데이터 변경이 발생할 때마다 변경일자와 함께 새로운 이력 레코드를 쌓는 방식을 ‘점이력’이라고 흔히 말한다. 다음은 그 예시이다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_369-1.jpg)

점이력 모델에서는 일반적으로 서브쿼리를 이용한다.

```sql
select a.고객명, a.거주지역, a.주소, a.연락처, b.연체금액, b.연체개월수 
from 고객 a, 고객별연체이력 b 
where a.가입회사 = 'C70' 
and b.고객번호 = a.고객번호 
and b.변경일자 = 
(
	select max(변경일자) 
	from 고객별연체이력 
	where 고객번호 = a.고객번호 and 변경일자 <= a.서비스만료일
)
```

# 궁금한 내용 / 부족한 내용

딱히 없는 것 같다.

# 느낀 점

많이 어렵다… 필요할 때 다시 봐야할 내용인 것 같다.