# 공부한 내용

## 반정규화는 무엇이고 왜 할까?

반정규화는 일반적으로는 “칼럼의 반정규화”를 일컫으며 데이터를 중복해서 저장하는 작업을 뜻한다.

반정규화의 대상이 되는 테이블에는 주로 업무적으로 밀접하게 연관되어있어 JOIN 연산으로 인한 성능 저하를 방지하고 싶은 테이블이 있다.

반정규화를 시행하면 시스템의 성능향상, 그리고 개발과 운영의 단순화 등의 효과가 있으며, 테이블 자체는 조금 복잡해질 수 있지만, 이로 인해 현실적인 성능 향상을 얻게 된다.

> 개발과 운영이 단순해지는 것도 어떻게 보면 회사 입장에서 똑같은 월급을 주는 건데 직원들이 더 효율적으로 일하게 되는 거기 때문에 성능 향상이라 할 수 있을 것 같다.
>

반정규화는 정규화와 마찬가지로 초기단계에서 진행할수록 좋으며, 일반적으로 정규화를 1차적으로 진행한다음 반정규화를 통해 몇 개의 테이블을 합치게 된다.

(개인적인 생각이지만 1트만에 어떤 테이블을 정규화하고 반정규화할지 모두 파악하는 것은 매우 어려울 것 같다는 생각이 든다.)

## 반정규화의 적용 방법

일단 반정규화를 적용하기 전에 먼저 알아야 할 점은, 반정규화를 시행했을 때 데이터의 무결성이 깨질 수 있다는 리스크가 반드시 존재한다는 점이다.

따라서 반정규화는 웬만하면 성능 향상 면에서 가장 나중에 시도해야할 방법이고, 시도한다 하더라도 그 전에 데이터 무결성을 보장할 수 있는 보험과 같은 방법을 먼저 시도해보고 해야 한다.

### 반정규화의 대상

- 데이터가 대량인 경우
- 비즈니스적으로 해당 테이블이 자주 쓰이고, 항상 일정한 범위를 조회하는 경우
- 통계적 정보를 따로 도출해야 할 때
- 지나치게 많은 JOIN이 걸려서 조회가 어려운 경우

### 반정규화 전에 시도해볼 수 있는 방법

- View를 생성하여 접근하도록 한다.
- 클러스터링을 적용한다. (조회중심 테이블 한정)
- 인덱스를 조정한다.
- 파티셔닝 기법을 적용한다. → 테이블은 그대로인데, 물리적인 저장소를 나눈다.
- 어플리케이션 영역에서 캐시 작업 등을 진행한다.

## 반정규화 기법들

### 테이블 반정규화

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_091.jpg)

### 칼럼 반정규화

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_092.jpg)

### 관계 반정규화

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_093.jpg)

## 정규화된 테이블의 성능 저하 사례

### 사례 1 (성능이 저하될 수도 있는 경우)

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_094.jpg)

```sql
SELECT A.공급자명, B.전화번호, C.메일주소, D.위치 
FROM 공급자 A,
	(SELECT X.공급자번호, X.전화번호 FROM 전화번호 X,
		(SELECT 공급자번호, MAX(순번) 순번 
			 FROM 전화번호 
			 WHERE 공급자번호 BETWEEN '1001' AND '1005' 
			 GROUP BY 공급자번호) Y 
			 WHERE X.공급자번호 = Y.공급자번호 AND X.순번 = Y.순번) B, 
				 (SELECT X.공급자번호, X.메일주소 
					FROM 메일주소 X, 
					 (SELECT 공급자번호, MAX(순번) 순번 
						FROM 메일주소 
						WHERE 공급자번호 BETWEEN '1001' AND '1005' 
						GROUP BY 공급자번호) Y 
						WHERE X.공급자번호 = Y.공급자번호 AND X.순번 = Y.순번) C, 
						 (SELECT X.공급자번호, X.위치 
							FROM 위치 X, 
							 (SELECT 공급자번호, MAX(순번) 순번 
								FROM 위치 
								WHERE 공급자번호 BETWEEN '1001' AND '1005' 
								GROUP BY 공급자번호) Y 
								WHERE X.공급자번호 = Y.공급자번호 AND X.순번 = Y.순번) D 
								WHERE A.공급자번호 = B.공급자번호 AND A.공급자번호 = C.공급자번호 AND A.공급자번호 = D.공급자번호 AND A.공급자번호 BETWEEN '1001' AND '1005'
```

정규화가 잘되어 있는 테이블이지만 이와 같이 말도 안되는 길이의 쿼리를 통해 조회해야 하는 것을 볼 수 있다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_096.jpg)

```sql
SELECT 공급자명, 전화번호, 메일주소, 위치 
FROM 공급자 
WHERE 공급자번호 BETWEEN '1001' AND '1005’
```

반면 약간의 반정규화를 거치면 쿼리가 아주 간결해진다.

### 사례 2 (성능이 저하된 경우)

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_101.jpg)

분산 데이터베이스 환경에서도 테이블 조인 비용과 더불어 서버 조인 비용까지 계산하면 상당한 성능 저하가 발생하는데, 반정규화를 통해 이를 해결할 수 있다.

# 어려웠던 내용


예시와 관련된 내용 제외하면 딱히 없었던 것 같다.

사실 자세한 내용을 알려고 하면 좀 머리 아프긴 한데, 일단은 데이터를 중복 저장하는 컬럼 반정규화 쪽을 중심으로 알고 있으면 될 것 같다.

# 궁금한 내용 / 부족한 내용


## Q1. View란 무엇인가?

### 개요

반정규화 전에 시도할 수 있는 방법 중 하나로 View라는 개념이 나왔는데, 이제까지 알던 게 MVC 패턴의 View밖에 없어서 한 번 찾아보았다.

### View란?

뷰는 SQL에 존재하는 개념으로, 다른 테이블에서 파생된 테이블을 의미한다.

```sql
create view emp30 as select * from employee where dno=30; 
```

이렇게 실제로 쿼리로 쓸 수 있는 SQL에 존재하는 개념이다.

### View를 쓰면 좋은 점

경우에 따라 자주 사용되는 복잡한 쿼리를 미리 뷰로 정의해두면, 추후 간단한 형태로 표현/조회가 가능하다고 한다.

반정규화 전에 뷰를 사용해볼 수 있다고 하는 것은, 아마도 개발자들 간의 쿼리가 전부 제각각이라, 가장 최적화된 쿼리를 뷰로 저장해두고 사용하는 게 아닌가 싶다.

## Q2. DB 클러스터링과 파티셔닝의 차이는 무엇인가?

### 개요

데이터베이스 성능 향상의 방법 중 DB 클러스터링과 파티셔닝이라는 용어가 나와서 둘의 차이가 궁금해졌다. 둘 다 뭔가 DB를 나눈다는 느낌인 건 알겠는데 자세한 차이가 궁금해졌다.

### 차이점?

조사해본 결과, DB 클러스터링은 DB 저장소는 건드리지 않고, DB 관리 서버를 여러 개로 나누어서 부하를 감당하는 방식이다.

반면 DB 파티셔닝의 경우 서버와는 상관없이 물리적 공간, 즉 저장소 안의 테이블이나 인덱스를 직접적으로 분할한다.

즉 클러스터링은 서버를 포함한, 보다 시스템 전체에 가까운 작업이라 할 수 있고, 파티셔닝은 DB 저장소 자체와 관련된 부분이라 할 수 있다.

### DB 클러스터링의 장점

DB 클러스터링의 경우 DB로 오는 요청들을 적절하게 분산처리함으로써 부하를 줄여주는 효과가 있다. 그리고 서버 하나가 다운되더라도 나머지 서버가 정상적으로 기능을 수행할 수 있다.

> 통상적으로 현실에서는 자리 10개가 있는 식당에 손님 100명이 있다면, 손님 10명은 앉아서 식사를 하고 나머지 90명은 웨이팅을 하다가 차례대로 들어가게 된다.

하지만 DB는? 처리량이 10인 DB에 100의 요청이 들어와버리면 그 자리에서 과부하로 서버가 죽게 된다. 이런 상황을 방지하기 위해 여러 개의 서버를 클러스터링을 통해 관리해야 할 필요가 있다.
>

### DB 파티셔닝의 장점

그리고 DB 파티셔닝의 경우, 주된 장점은 성능 향상이며, 테이블의 백업 및 복구 작업에도 도움이 된다.

> 카카오톡 서비스의 경우, 시간이 지남에 따라 데이터의 중요도와 사용 빈도가 달라지는데, 2020년 이전의 대화 데이터는 현재 시점의 대화 데이터에 비해 조회 횟수가 현저히 적을 가능성이 높다.

따라서 이러한 데이터를 시간 기준으로 파티셔닝하고, 조회 횟수가 적을 것 같은 데이터에는 더 적은 서버 리소스를 할당함으로써, 전체 시스템의 성능과 효율성을 높일 수 있으며 비용 절감 역시 가능하다.
>

# 느낀점


아직 상세하게는 아니지만, 정규화와 반정규화라는 개념에 대해 어느정도 알게된 것 같다.

상세한 내용들은 아마도 실전적으로 데이터 모델링을 경험해봐야 알 수 있을 것 같아서, 다음에 프로젝트 때 기회가 되면 정규화를 일단 3형까지 거치고, 비즈니스적으로 필요한 부분에 반정규화를 진행해야할 것 같다.

이번에 DB 클러스터링, DB 파티셔닝에 관한 개념도 추가로 학습해보았는데, 이제야 뭔가 좀 DB 공부 하는 것 같고 똑똑해지는 느낌이다. ㅋㅋㅋ

이제 본격적으로 대용량 데이터에 관한 개념, 그리고 성능에 관한 개념들이 나오는 것 같은데 아주아주 흥미롭다. 열심히 해보자 ㅋㅋ